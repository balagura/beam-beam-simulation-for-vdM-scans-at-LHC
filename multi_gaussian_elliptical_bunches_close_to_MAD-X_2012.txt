# This file describes van der Meer scan in ATLAS simulated using MAD-X in
# 2012.
#----------------------------------------------------------------------
#
# Beam momentum in GeV
p = 3500.

# Charge of particles in beam1 and beam2 in units of the proton charge
Z1 = 1
Z2 = 1

# Value of the beta-function in the interaction point (beta-star), in meters
beta = 1.5

# The tune values (the number of betatron transverse oscillation periods in one
# LHC orbit), from Hostettler PhD, p.25, Table 4.1
# before_2017:
Qx = 64.31
Qy = 59.32

# Number of particles in the second (creating the field) bunch
N2 = 8.5e10

# The traced points of the 1st bunch are selected in the following way. The
# first bunch Gaussian is sampled in two-dimensional X-Y grid covering
# +/-N.sigma * sig1.x times +/-N.sigma * sig1.y rectangle with
# int(sqrt(N.points)) points along each side. Then, all points with
# sqrt((X/sig1.x)^2 + (Y/sig1.y)^2) distance greater than N.sigma are
# removed. Positions of all remaining points are traced N.turns in the
# accelerator.
N.sigma = 5
N.points = 10000

# Beam-beam interaction is switched on not immediately but after
# N.no.beam.beam.turns in accelerator. This allows to calculate numerically
# the undisturbed overlap integral, compare it with the exact analytic formula
# and estimate the bias of the numerical integration. The final correction is
# then calculated as the ratio of the numerical integration with and without
# the beam-beam interaction. The bias is cancelled in the ratio at least
# partially and this potentially allows to improve the precision.
N.no.beam.beam.turns = 1000

# Beam-beam interaction can be switched on not abruptly but "adiabatically",
# linearly from zero to its nominal value during N.transitional.turns
# N.transitional.turns can be omitted, then it is assigned to 1000 by default
N.transitional.turns = 1000

# After beam-beam is fully switched on, one should wait for the
# stabilization. Normally, it is reached after <2000 turns (much less if
# beam-beam is switched on adiabatically).
# If N.stabilization.turns is omitted, it is set by default to 2000
N.stabilization.turns = 1000

# After N.no.beam.beam.turns + N.transitional.turns + N.stabilization.turns
# turns, the positions of the selected points (the intersections of their
# orbits with the X-Y plane at the Interaction Point) are calculated in the
# accelerator during N.turns.with.beam.beam. This is the period when the
# luminosity correction is determined.
N.turns.with.beam.beam = 5000

# 1st and 2nd bunch Gaussian sigmas in X and Y in um
sig1.x = 39.99 80.01
sig1.y = 30.01 40.01 60.01
sig2.x = 40.01 79.99 120.01
sig2.y = 39.99 100.01

b1x.gaussian.weight = 99 1
b1y.gaussian.weight = 0.005 0.99 0.005
b2x.gaussian.weight = 0.99 0.005
b2y.gaussian.weight = 99 1

# The sequence of X,Y positions of the 2nd bunch center w.r.t. the 1st one in
# um as two white-space separated lists (corresponding to the van der Meer
# scan steps)
x2 = 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20.
y2 = 0  0  0  0  0  0  0  0  0  0   0   0   0   0   0   0   0   0   0   0   0.

# If scale_x,y_by below are given, x2, y2 are multiplied by these scaling factors
scale_x_by = 10
# scale_y_by = 10

# What should be the output of the computation (a white-space separated list
# of keywords below, the files will be named like
# "beam_beam_output_<keyword>.txt.gz" except the shortest
# "beam_beam_output_summary.txt" which will not be gzip'ed):
#
#   "summary"   the main results on the overlap rho1 * rho2 integrals and the
#               corresponding beam-beam correction. This file will always be
#               printed, regardless of the settings.
#
#   "rx.ry.weights"   for every point: its maximal x and y (ie. the circle radii
#                     rx, ry in x,x' and y,y' phase spaces, x',y' denote the
#                     derivatives w.r.t. z multiplied by beta) and "weights" at 
#                     which the point should be taken in the averages (the
#                     cenetral points have more weight).
#                     Format: step x2 y2 point rx ry weight
#
#   "integrals" overlap integrals per turn (not averaged), rho1,2 bunch
#               densities are either modified by the beam-beam electromagnetic
#               interaction or not, depending on whether the accelerator turn
#               is greater than "N.no.beam.beam.turns" or not, respectively.
#               Format: step x2 y2 turn integral
#
#   "centers"   averaged over points x- and y-positions per turn
#               Format: step x2 y2 turn average_x average_y
#
#   "points"    the traced points of the 1st bunch after accelerator turn "i",
#               this file might be very long.
#               Format: step turn point x x'*(-beta) y y'*(-beta)
#                 where x',y' are the corresponding angles wrt. z
#
output = rx.ry.weights integrals centers points

# By default all output files and also the copy of the configuration file will
# be stored in the subdirectory with the name obtained by dropping .txt from
# the end of the configuration file name, like
# beam_beam_1.txt -> beam_beam_1/. One can overwrite this rule by giving an
# explicit name (relative to the current directory or absolute) below.
# A fresh output subdirectory will be created. If it already exists, the program
# will terminate without overwriting anything.
# output.directory = beam_beam_lhcb_example

# Storage of the traced point positions after all accelerator turns might
# require too much disk space. Instead, one can "select.one.turn.out.of" N
# turns.  Eg. if this parameter is 100, only the positions of the points after
# 0, 100, 200, ... turns will be stored. If storage of "point"s is not
# requested in "output", select.one.turn.out.of has no effect.
select.one.turn.out.of = 1000

# Seed for the random number generator. If not given, the current time will be
# used as a seed.
# seed = 12121212121

# To speed up the simulation, the field E generated by the second bunch at a
# given point is determined using a bilinear interpolation.  For that, the
# precise field is precalculated at the grid of points and interpolated in
# between. The accuracy of the interpolation is estimated and printed out in
# the end. If the interpolation is not desired, the following parameter
# "calculate.field.without.interpolation" can be set to TRUE. In this
# case the field will be calculated using exact formulas and the parameters
# below controlling the interpolation, "N.cells.along.grid.side" and
# "N.random.points.to.probe.field.map", will have no effect.
# calculate.field.without.interpolation = TRUE

# The interpolation grid is chosen to cover +/- 1.1 * N.sigma.cut * sig1.x,y
# in X and Y, respectively, around the first bunch center and for all set
# separations between two bunches. It should be sufficiently wide to cover all
# simulated without beam-beam particle trajectories (ie. circles), while with
# 10% margins (with the factor 1.1) the grid likely covers also the
# trajectories deformed by the beam-beam interaction. If not, ie. if some
# point goes beyond the interpolation grid, the program falls back to the
# calculation of the exact field instead of the interpolation. The grid forms
# a matrix of (N.cells.along.grid.side X N.cells.along.grid.side) cells. The
# number of points is, therefore, (N.cells.along.grid.side+1) X
# (N.cells.along.grid.side+1).
N.cells.along.grid.side = 500

# To check the precision of the interpolation, the absolute mismatches between
# the interpolated and precise field values (ie. the length of their
# difference) is calculated at N.random.points.to.probe.field.map distributed
# randomly inside (xmin, xmax, ymin, ymax) rectangle. The maximal and average
# mismatches normalized to the maximal field value are printed out. If this
# cross check is not necessary, please, set N.random.points.to.probe.field.map
# to zero.
N.random.points.to.probe.field.map = 10000

# For the debugging purposes one can redefine the kick formula by choosing
# the "kick.model" parameter below from the list:
#  precise, 
#  precise.minus.average,
#  average, 
#
# By default it is set to "precise" (also when kick.model is left undefined),
# then the exact kick formula is used.
#
# "average" means constant X,Y-independent kick equal to the value averaged
# over the bunch. Ie. the value of this constant angular kick is chosen to be
# equal to the sum of the kicks of all bunch particles divided by their
# number. This constant average kick only depends on the bunch separation, but
# not on X,Y. Namely, for the Gaussian bunches it can be calculated as the action of the bunch with
# (Capital) sigma = sqrt(sigma1^2 + sigma2^2) on one particle placed at the
# distance equal to the separation between the bunches. Ie. bunch one should
# be substituted by one particle at its center, while sigma of bunch 2 should
# be changed to this Capital sigma. Such constant kick only shifts the first
# bunch center, but do not modify its shape, so the resulting luminosity
# change can be computed using analytic formula.
#
# "precise.minus.average" means that the kick is equal to
# precise kick - average kick. Here, "average.kick" is the same as with
# kick.model = average. This "precise.minus.average" model is implemented to
# demonstrate that the "precise" results coincide with the combined correction
# from kick.model = precise.minus.average and kick.model = average. Ie. the
# "precise" correction can be decoupled into two: from the orbit change and
# from the relative change of the bunch shape but with the fixed orbit
# (ie. using the kick = precise - average).
#
#
kick.model = precise
