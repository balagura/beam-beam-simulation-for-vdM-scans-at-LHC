# Example of modelling the beam-beam perturbation in 4 interaction points
# (IPs) with multi-Gaussian shapes of one "kicked" and four "kicker" bunches.
#
# All multi-Gaussian components and other beam parameters at all IPs are,
# however, chosen to be almost identical to that of van Meer scan in ATLAS
# simulated using MAD-X in 2012. Eg. the multi-Gaussians are the sums of 1-4
# almost identical Gaussians with various weights. The result of the
# simulation at every IP should, therefore, be the same as for a single
# Gaussian, single IP case. This allows to debug the simulation.
#----------------------------------------------------------------------
#
#                         Beam parameters
#
#----------------------------------------------------------------------
# Beam momentum in GeV
#
p = 3500.

# Charge of the particles in the kicked (simulated) and the kicker bunches
# (creting the field) in units of the proton charge
#
Z.kicked = 1
Z.kicker = 1

# Number of interaction points
#
N.IP = 4

# The value of the beta-function at the simulated interaction points
# (beta-star), separately along X and Y, in meters.
#

# Here, for testing, the last beta is 4 times larger. This is compensated by
# twice larger sigmas and beam separations.
# Indeed, at IP with d beta/dz = 0, the invariant variables are:
#
# x    /sqrt(beta) =  emittance*cos(pahes) and
# dx/dz*sqrt(beta) = -emittance*sin(phase).
#
# If one scales x (ie. sigmas and beam separations) as sqrt(beta), the first
# variable will remain invariant. The electric field (proportional to 1/x) and
# the angular kick of dx/dz will scale as 1/sqrt(beta). Then, the kick of the
# second variable dx/dz*sqrt(beta) will scale as sqrt(beta)/sqrt(beta),
# ie. will also remain invariant. Therefore, the dynamics of these two
# variables will remain the same (if the number of particles in the kicker
# bunch also remains the same).
#
kicked.x.beta = 1.5 1.5 1.5 6.
kicked.y.beta = 1.5 1.5 1.5 6.

# Number of particles in the kickers
#
N.kicker.particles = 8.5e10 8.5e10 8.5e10 8.5e10

# kicked bunch Gaussian sigmas and weights in X and Y, in um, at the
# interaction point "kicked.ip" whose counting starts from one. The kicked
# sigmas at other IPs are equal to sigma(kicked.ip) * sqrt(beta(ip) /
# beta(kicked.ip).
#
# Note that contrary to the kicked bunch defined at "kicked.ip" and
# extrapolated to other IPs with the beta-function, the kicker sigmas should
# be given directly at the IP of the beam-beam interaction, without any
# extrapolation. In other words, such kicker sigmas, in general, can differ
# from the kicker sigmas at "kicked.ip".
#
kicked.ip = 1

#
# Here, in X the distribution is double Gaussian but with the same widths, in
# Y - single Gaussian
#
kicked.x.sig = 40 40
kicked.y.sig = 40

# Gaussian weights can be given not normalized. Here, in X the proportions
# will be 1:2. In Y, for a single Gaussian, the weight can be omitted.
#
kicked.x.weight = 1 2
# kicked.y.weight = 1

# Gaussian sigmas and weights in X and Y, in um, for the kicker bunches at all
# IPs
#
kicker.1.x.sig = 40 40
kicker.1.y.sig = 40 40

# The last Gaussian weight can be omitted, then it is set to the value
# complementing the total weight to one. Note, this means that eg. for a
# triple Gaussian (when 3 sigmas are given) the weights 50 49 will be
# complemented not by 1 (they are not in percent) but by 1 - (50+49) = -98.
# So, this option is useful only when the weights are normalized.
#
kicker.1.x.weight = 0.9
kicker.1.y.weight = 0.9 0.1

# If the kicker density and the field are interpolated (see below), the
# simulation of multi-Gaussian (round or elliptical) bunches and
# single-Gaussian ones takes about the same time. So, the elliptical
# four-Gaussian below does not slow down the simulation
#
kicker.2.x.sig = 40.002 39.999 40.001 39.998
kicker.2.y.sig = 40.
kicker.2.x.weight = 2 10 10 2
kicker.2.y.weight = 0.001

kicker.3.x.sig = 40 40
kicker.3.y.sig = 40
kicker.3.x.weight = 1 1
# kicker.3.y.weight = 10

kicker.4.x.sig = 80 80
kicker.4.y.sig = 80.001 79.999
kicker.4.x.weight = 20 80
kicker.4.y.weight = 1 1

# The sequence of X, Y kicker bunch center coordinates w.r.t. the kicked
# bunch, in um. Every (X, Y) pair corresponds to one van der Meer scan step.
#
# The length of all vectors should be either one or maximal. If it is one, the
# corresponding coordinate is assumed to be constant during the scan.
#

# Below, the separations at all IPs are the same, to have the same results
# everywhere
#
kicker.1.x = 0.  10.  20.  30.  40.  50.  60.  70. 80. 90. 100. 110. 120. 130. 140. 150. 160. 170. 180. 190. 200.
kicker.1.y = 0

kicker.2.x = 0.  10.  20.  30.  40.  50.  60.  70. 80. 90. 100. 110. 120. 130. 140. 150. 160. 170. 180. 190. 200.
kicker.2.y = 0

kicker.3.x = 0.  10.  20.  30.  40.  50.  60.  70. 80. 90. 100. 110. 120. 130. 140. 150. 160. 170. 180. 190. 200.
kicker.3.y = 0

kicker.4.x = 0.  1.  2.  3.  4.  5.  6.  7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19. 20.
kicker.4.y = 0

# If scale.by is given as below, the corresponding coordinate is multiplied by this scaling factor
# Here, the overall scale is twice larger to compensate 4 times larger beta:
#
kicker.4.x.scale.by = 20.
kicker.4.y.scale.by = 1000000

# The phases/2pi relative to ATLAS IP at LHC in vdM scans from Guido Sterbini MAD-X simulation:
# https://indico.cern.ch/event/836681/contributions/3507678/attachments/1884149/3105236/2019_07_22.pdf
# indico: https://indico.cern.ch/event/836681/
#  
#      Qx1       Qy1       Qx2       Qy2
#  0.000000  0.000000  0.000000  0.000000
#  8.295954  7.669167  8.272802  7.957720
# 31.975690 29.648602 31.984398 29.761319
# 56.064831 51.017069 55.799012 51.715754
# 64.310000 59.320000 64.310000 59.320000
#
# Simulated kicked bunch in beam 1, kicker bunches in beam 2:
# kicker.x.next.phase.over.2pi = 8.295954 31.975690 56.064831 64.310000
# kicker.y.next.phase.over.2pi = 7.669167 29.648602 51.017069 59.320000
#
# The phase at IP 1 is zero by definition, therefore, the arrays above start from
# the phase at IP 2, this is why they are called "next" phase over 2pi
#
# Simulated kicked bunch in beam 2, kicker bunches in beam 1:
# kicker.x.next.phase.over.2pi = 8.272802 31.984398 55.799012 64.310000
# kicker.y.next.phase.over.2pi = 7.957720 29.761319 51.715754 59.320000
#
#
# Instead of the values above, for debugging purposes, here the full tunes are
# chosen below for all phases/2pi. Then, all IPs become equivalent and the
# results should coincide with the single-IP case.
#
kicker.x.next.phase.over.2pi =  64.31 128.62 192.93 257.24
kicker.y.next.phase.over.2pi =  59.32 118.64 177.96 237.28

# Phases/2pi or full tunes might be given with 2-3 digits after the
# comma. So, after 100 or 1000 turns the points return to their original
# positions (as 100* or 1000 * Qx,y becomes integer). To avoid this and add
# extra randomness, a "negligible" irrational number randomly distributed
# in the interval -exp(-8.5)...+exp(-8.5) = +/-0.0001017342 is added by
# default to deltaQ. This makes it irrational and opens otherwise closed
# Lissajous figures of betatron oscillations in X-Y plane. In reality the
# phases/2pi are always irrational.
#
# If this is not desired, an option
#   exact.phases = TRUE
# should be set. Then all phases/2pi from the configuration file are used
# "as is".
#
# exact.phases = TRUE


#----------------------------------------------------------------------
#
#                        Simulation parameters
#
#----------------------------------------------------------------------
# The traced points of the "kicked" bunch are selected in the following way.
#
# The bunch density factorizes in X and Y. Its projections to X and Y are two
# multi-Gaussian distributions.  Because of the circular motion in X-X' and
# Y-Y' planes (where X',Y' denote the angular coordinates scaled by the
# accelerator beta-function, eg. X' = dX/dZ * beta), the projections to X'
# (Y') are identical to X (Y). So, eg. a single Gaussian in X makes a
# two-dimensional Gaussian with equal sigmas in X-X' plane, and a
# multi-Gaussian makes a multi two-dimensional Gaussian with the same weights.
#
# The four-dimensional bunch density is sampled in a two-dimensional rX-rY
# grid of the radii in the X-X', Y-Y' planes at the first interaction point.
#
# Each grid side (rX or rY) extends from 0 to a maximal radius rX,Y_max. The
# latter is chosen such that the circle with the radius rX_max (or rY_max)
# contains the the same fraction of a multi two-dimensional Gaussian as that
# of a single two-dimensional Gaussian inside the circle with the radius
# "N.sigma".
#
# The number of grid lines in rX and rY are the same and equal to
# int(sqrt("N.points")). Finally, only rX-rY points inside the ellipse
# inscribed to the rectangle (rX_max X rY_max) are used for the
# simulation. For every selected rX-rY pair, one point at the X-X', Y-Y'
# circles with these radii and random phases is traced in the accelerator.
#
N.sigma.cut = 5
N.points = 5000

# There are several "phases" in the simulation.
#
# First phase is without beam-beam. It allows to calculate numerically the
# undisturbed overlap integral, compare it with the exact analytic formula and
# estimate the bias of the numerical integration. The final correction is then
# calculated as a ratio of the numerical integrals with (last phase) and
# without (first phase) the beam-beam interaction. The bias is cancelled in
# the ratio at least partially and this potentially allows to improve the
# precision.
#
# During the second phase the beam-beam interaction is switched on
# "adiabatically": linearly with the turn number from zero to its nominal
# value. If this phase is omitted (zero turns) the switch is abrupt: from
# zero to nominal.
#
# After beam-beam is fully switched on, there might be a need to wait for the
# stabilization. This is the third phase. With the adiabatic switch on
# (eg. during 1000 turns) the stabilization phase can normally be omitted and
# the corresponding number of turns can be set to zero.
#
# The final, fourth phase is with beam-beam. Only this phase is used to
# calculate the perturbed overlap integral and the luminosity correction.
#
# The following parameter defines the number of turns in 4 phases
#
N.turns = 1000 1000 0 5000

# To speed up the simulation, the X- and Y-densities of the kicker bunch at a
# given point are determined using linear (one-dimensional) interpolations,
# while the generated field E - using a bilinear (two-dimensional)
# interpolation. For that, the precise density and the field are precalculated
# at the grid of points and interpolated in between.
#
# The interpolation grid is chosen to minimally cover the ranges +/- 1.1 *
# rX_max, +/- 1.1 * rY_max around the kicked bunch center but viewed from the
# kicker bunch center for all set kicker separations. Here, rX,Y_max are the
# maximal simulated radii in X-X' and Y-Y' planes.  Therefore, the grid is
# sufficiently wide to cover all simulated without beam-beam particle
# trajectories (circles), while with 10% margins (with the factor 1.1) it
# likely covers also the trajectories deformed by the beam-beam
# interaction. If not, ie. if some point goes beyond the interpolation grid,
# the program falls back to the calculation of the exact field instead of the
# interpolation.

# The linear (bilinear) grid is a raw (a matrix) of N (NxN) cells and has the
# total number of points N+1 ((N+1)*(N+1)). N is defined separately for the
# one-dimensional (X,Y)-density and for the two-dimensional field
# interpolators by the following parameter
# "Density.and.Field.interpolators.N.cells.along.grid.side". If the
# interpolation is not desired, the corresponding N should be set to zero,
# like "0 500". The first number is for the density, the second - for the
# field, so the density will be calculated using exact formulas while the
# field will be interpolated with N=500.
#
Density.and.Field.interpolators.N.cells.along.grid.side = 500 500

# The interpolators are created not for each kicker bunch but for each group
# of identical bunches. Ie. if there are identical kickers, the interpolators
# are reused to save memory.
#
# The accuracy of the interpolation can be estimated if the parameter
# "N.random.points.to.check.interpolation" below is given. This is performed
# by measuring the maximal and average absolute mismatches between the
# interpolated and the exact values at
# "N.random.points.to.check.interpolation" distributed inside the
# interpolation grid. The mismatches are then normalized to the maximal
# absolute exact value and printed out.
#
# If the interpolation was switched off by setting one or both
# "Density.and.Field.interpolators.N.cells.along.grid.side" values to zero,
# the corresponding "N.random.points.to.check.interpolation" has no
# effect. The check is not performed either if
# "N.random.points.to.check.interpolation" is set to zero.
#
N.random.points.to.check.interpolation = 10000

# Seed for the random number generator. The results of the simulation will be
# fully reproducible if this parameter is specified. Otherwise, the current
# time will be used as a seed, and the results will be not reproducible.
seed = 123456789

# For the debugging purposes one can redefine the kick formula by setting
# "kick.model" parameter to one of the following:
#
#  precise
#  precise.minus.average
#  average
#
# If not specified, "precise" is used by default. In this case the exact kick
# formula is used.
#
# "average" means constant X,Y-independent kick equal to the value averaged
# over the kicked bunch, ie. to the sum of the kicks of all bunch particles
# divided by their number. This average kick depends only on the bunch
# separation, but not on X,Y. For the Gaussian bunches it can be calculated as
# the action of the kicker bunch with (Capital) sigma = sqrt(sigma1^2 +
# sigma2^2) on one particle placed at the kicked bunch center. The constant
# kick only shifts the first bunch center ("orbit shift"), but do not modify
# its shape, so the resulting luminosity change can be computed using analytic
# formula.
#
# "precise.minus.average" means that the kick is chosen to be the difference
# "precise" - "average".  This model is implemented to demonstrate that the
# "precise" beam-beam luminosity corrections coincide with (and can be
# decoupled to) the sum of the corrections obtained with
# "precise.minus.average" and "average".
#
kick.model = precise

#----------------------------------------------------------------------
#
#                            Output
#
#----------------------------------------------------------------------
# "output" and "output.1" ("output.2" ...) parameters below control what
# should be the output of the simulation. It is a white-space separated list
# of options. For every option XXXX.XXXX one compressed file will be generated
# under the name "XXXX_XXXX.txt.gz".
#
# "output" is for the kicked bunch and can contain only one option:
#
#   "rx.ry.weights" for every simulated particle: its initial rX and rY radii
#                   (in X,X' and Y,Y' phase spaces) at ip and its "weight"
#                   Format: i.particle ip rx ry weight
#
# "output.1", "output.2" ... are for the kickers at IP 1, 2 ... . They can have
# several options:
#
#   "integrals.per.turn" overlap integrals per turn (averaged over particles).
#                        Format: step ip ip.kicker.x ip.kicker.y i.turn integral
#
#   "avr.xy.per.turn" average kicked bunch center per turn (averaged over
#                     particles)
#                     Format: step ip i.turn average.x average.y
#

#   "integrals.per.particle" overlap integrals per particle, per phase
#                            (averaged over turns in the given phase),
#                            assuming that the kicked bunch is squashed to
#                            this particle, ie. the bunch density is a
#                            delta-function at its position.
#                            Format: step ip phase i.particle integral
#
#   "avr.xy.per.particle"   average kicked bunch center per particle, per phase
#                           as above.
#                           Format: step ip phase i.particle avr.x avr.y
#

#   "points"  the traced positions of the kicked bunch particles after
#             accelerator "i.turn", note, this file might be very long.
#             Format: step ip i.turn i.particle X X' Y Y'
#
# The integers i.turn and i.particle are counted from zero.
#
# In addition, the files "kicker_positions.txt" and "summary.txt" are always
# printed out regardless of the settings.
#
#     The first, "kicker_positions.txt", links the "step" number with the
#     kicker coordinates. Namely, it contains the set coordinates of the
#     kicker bunch centers at all IPs with respect to the kicked bunch center.
#     Format: step ip x y
#
#     The second file, "summary.txt" contains the main results of the
#     simulation including the overlap integrals and the corresponding
#     beam-beam corrections.
#     Format: step IP (beam-beam/no beam-beam luminosity correction)
#     (analytic, numeric no beam-beam overlap integrals, their ratio and its error;
#     note, error = -9999 if "integrals.per.turn" option is not selected in "output")
#     (X,Y average shift of the kicked bunch due to beam-beam interactions in all IPs
#     - only if "centers.per.particle" is requested in "output")
#     (the same shift analytically calculated but from beam-beam in this IP only)
#
# output = rx.ry.weights
#
# output.1 = integrals.per.turn avr.xy.per.turn integrals.per.particle avr.xy.per.particle points
# output.2 = integrals.per.turn avr.xy.per.turn integrals.per.particle avr.xy.per.particle points
# output.3 = integrals.per.turn avr.xy.per.turn integrals.per.particle avr.xy.per.particle points
# output.4 = integrals.per.turn avr.xy.per.turn integrals.per.particle avr.xy.per.particle points
# 
output.1 = integrals.per.turn integrals.per.particle avr.xy.per.particle
output.2 = integrals.per.turn integrals.per.particle avr.xy.per.particle
output.3 = integrals.per.turn integrals.per.particle avr.xy.per.particle
output.4 = integrals.per.turn integrals.per.particle avr.xy.per.particle

# Storage of the traced particle positions (if the output option "points"
# above is specified) after every accelerator turn might require too much disk
# space. Instead, one can "select.one.turn.out.of" N turns.  Eg. if this
# parameter is set to 1000, only the positions after i.turn = 999, 1999, 2999,
# ...  (counting from zero) will be stored. If "points" option is not
# requested in "output", "select.one.turn.out.of" has no effect.
#
select.one.turn.out.of = 1000

# By default all output files and also the copy of the configuration file will
# be stored in the subdirectory with the name obtained by dropping .txt from
# the end of the configuration file name, like beam_beam_1.txt ->
# beam_beam_1/.
#
# One can overwrite this rule by giving an explicit directory name (relative
# to the current directory or absolute) as "output.directory" parameter
# below. A fresh subdirectory with this name will be created. If it already
# exists, the program will terminate without overwriting anything.
#
# output.directory = some_subdirectory

